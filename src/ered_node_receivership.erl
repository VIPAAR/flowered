-module(ered_node_receivership).

-export([enter_receivership/3]).

-import(ered_nodes, [
    add_state/2,
    this_should_not_happen/2
]).
-import(ered_message_exchange, [
    post_completed/2
]).

increment_message_counter(NodeDef, CntName) ->
    {ok, V} = maps:find(CntName, NodeDef),
    maps:put(CntName, V + 1, NodeDef).

%%
%% this is called if a message type was received by a node that did not
%% claim to receive such messages
bad_routing(NodeDef, Type, Msg) ->
    this_should_not_happen(
        NodeDef,
        io_lib:format(
            "Node received unhandled type ~p Node: ~p Msg: ~p\n",
            [Type, NodeDef, Msg]
        )
    ),
    NodeDef.

bump_incoming(NodeDef) ->
    increment_message_counter(NodeDef, '_mc_incoming').
bump_outgoing(NodeDef) ->
    increment_message_counter(NodeDef, '_mc_outgoing').

%%
%% handle_event are systen events, these are generated by the system
%% and are not triggered by other nodes in the flow. Events such as
%% deploy or register inform the nodes of a system change and that the
%% nodes might need to do something or not (in the case of deploy).
catchall_receivership(CatchAll, Module, NodeDef, ReceiverType) ->
    case CatchAll of
        {stop, WsName} ->
            erlang:apply(Module, handle_event, [{stop, WsName}, NodeDef]);
        {incoming, Msg} ->
            NodeDef2 = bad_routing(bump_incoming(NodeDef), incoming, Msg),
            enter_receivership(Module, NodeDef2, ReceiverType);
        {outgoing, Msg} ->
            NodeDef2 = bad_routing(bump_outgoing(NodeDef), outgoing, Msg),
            enter_receivership(Module, NodeDef2, ReceiverType);
        {deploy, NewNodeDef} ->
            %% a deploy is nothing more the replacing the state
            %% of the process. Reset the state and we're done.
            {ok, NodePid} = maps:find('_node_pid_', NodeDef),
            NodeDef2 = erlang:apply(
                Module, handle_event, [deploy, add_state(NewNodeDef, NodePid)]
            ),
            enter_receivership(Module, NodeDef2, ReceiverType);
        {registered, WsName, Pid} ->
            NodeDef2 = erlang:apply(
                Module, handle_event, [{registered, WsName, Pid}, NodeDef]
            ),
            enter_receivership(Module, NodeDef2, ReceiverType)
    end.

%% used by the complete node to receive messages from nodes that have
%% completed. Ensure that it doesn't receive its own messages thus creating
%% and endless loop.
enter_receivership(Module, NodeDef, ReceiverType = completed_messages) ->
    receive
        {completed_msg, FromNodeDef, Msg} ->
            {NodeDef2, Msg2} = erlang:apply(
                Module,
                handle_completed_msg,
                [NodeDef, FromNodeDef, Msg]
            ),
            %% completed node marks the message as having been seen - to
            %% avoid endless loops - so therefore send the modified message
            %% here.
            %%
            %% Completed Nodes can also be listened to by a complete
            %% node, hence this post_completed is here.
            post_completed(NodeDef2, Msg2),
            enter_receivership(Module, NodeDef2, ReceiverType);
        CatchAll ->
            catchall_receivership(CatchAll, Module, NodeDef, ReceiverType)
    end;
%%
%% used by the ignore node, this is really a zombie node. Good for things
%% such as comment nodes.
enter_receivership(Module, NodeDef, ReceiverType = nothing) ->
    receive
        CatchAll ->
            catchall_receivership(CatchAll, Module, NodeDef, ReceiverType)
    end;
%%
%% used by catch nodes to receive exceptions from other nodes.
enter_receivership(Module, NodeDef, ReceiverType = only_exception) ->
    receive
        {exception, From, Msg, ErrMsg} ->
            %% From is the NodeDef of the source node and Msg is the
            %% Msg object it received. ErrMsg is a string explaining the
            %% situation.
            NodeDef2 = increment_message_counter(NodeDef, '_mc_exception'),
            {NodeDef3, Msg2} = erlang:apply(
                Module,
                handle_exception,
                [NodeDef2, From, Msg, ErrMsg]
            ),
            post_completed(NodeDef3, Msg2),
            enter_receivership(Module, NodeDef3, ReceiverType);
        CatchAll ->
            catchall_receivership(CatchAll, Module, NodeDef, ReceiverType)
    end;
%% the disabled and enabled messages are specifically for the debug node.
%% Active here is an attribute on the NodeDef that is used to turn the
%% debug node on and off. But it can also be used for other nodes if
%% necessary.
enter_receivership(Module, NodeDef, ReceiverType = only_incoming_with_active) ->
    receive
        {disable, _WsName} ->
            NodeDef2 = maps:put(active, false, NodeDef),
            enter_receivership(Module, NodeDef2, ReceiverType);
        {enable, _WsName} ->
            NodeDef2 = maps:put(active, true, NodeDef),
            enter_receivership(Module, NodeDef2, ReceiverType);
        {incoming, Msg} ->
            {NodeDef3, Msg2} = erlang:apply(
                Module, handle_incoming, [bump_incoming(NodeDef), Msg]
            ),
            post_completed(NodeDef3, Msg2),
            enter_receivership(Module, NodeDef3, ReceiverType);
        CatchAll ->
            catchall_receivership(CatchAll, Module, NodeDef, ReceiverType)
    end;
enter_receivership(Module, NodeDef, ReceiverType = websocket_events_and_stop) ->
    receive
        {ws_event, Details} ->
            NodeDef2 = increment_message_counter(NodeDef, '_mc_websocket'),
            NodeDef3 = erlang:apply(
                Module,
                handle_ws_event,
                [Details, NodeDef2]
            ),
            enter_receivership(Module, NodeDef3, ReceiverType);
        CatchAll ->
            catchall_receivership(CatchAll, Module, NodeDef, ReceiverType)
    end;
enter_receivership(Module, NodeDef, ReceiverType = incoming_and_outgoing) ->
    receive
        {incoming, Msg} ->
            {NodeDef3, Msg2} = erlang:apply(
                Module, handle_incoming, [bump_incoming(NodeDef), Msg]
            ),
            post_completed(NodeDef3, Msg2),
            enter_receivership(Module, NodeDef3, ReceiverType);
        {outgoing, Msg} ->
            {NodeDef3, _Msg2} = erlang:apply(
                Module, handle_outgoing, [bump_outgoing(NodeDef), Msg]
            ),
            enter_receivership(Module, NodeDef3, ReceiverType);
        CatchAll ->
            catchall_receivership(CatchAll, Module, NodeDef, ReceiverType)
    end;
%%
%% link call nodes need a third type of message and that is the response
%% from a link out node that is in return mode. But a link call node does
%% not require an outgoing message type so ignore that.
enter_receivership(Module, NodeDef, ReceiverType = link_call_node) ->
    receive
        {incoming, Msg} ->
            {NodeDef3, Msg2} = erlang:apply(
                Module, handle_incoming, [bump_incoming(NodeDef), Msg]
            ),
            %% in fact this will return a msg object to ensure nothing
            %% is posted - this is caught by the complete node.
            post_completed(NodeDef3, Msg2),
            enter_receivership(Module, NodeDef3, ReceiverType);
        {link_return, Msg} ->
            NodeDef2 = increment_message_counter(NodeDef, '_mc_link_return'),
            {NodeDef3, Msg2} = erlang:apply(
                Module, handle_link_return, [NodeDef2, Msg]
            ),
            post_completed(NodeDef3, Msg2),
            enter_receivership(Module, NodeDef3, ReceiverType);
        CatchAll ->
            catchall_receivership(CatchAll, Module, NodeDef, ReceiverType)
    end;
%%
%% incoming only nodes are things such debug or data stores node that receives
%% messages and store them. These nodes don't perform any computation on the
%% messages.
%% assert values fails if it never recevied a message
enter_receivership(Module, NodeDef, ReceiverType = only_incoming) ->
    receive
        {incoming, Msg} ->
            {NodeDef3, Msg2} = erlang:apply(
                Module, handle_incoming, [bump_incoming(NodeDef), Msg]
            ),
            post_completed(NodeDef3, Msg2),
            enter_receivership(Module, NodeDef3, ReceiverType);
        CatchAll ->
            catchall_receivership(CatchAll, Module, NodeDef, ReceiverType)
    end;
%%
%% outgoing only nodes are things like inject, http in and mqtt in - these
%% nodes are sources of messages but never receive these within the flow
%% rather they receive data from a third-party source and pass that data
%% into the flow.
enter_receivership(Module, NodeDef, ReceiverType = only_outgoing) ->
    receive
        {outgoing, Msg} ->
            {NodeDef3, Msg2} = erlang:apply(
                Module, handle_outgoing, [bump_outgoing(NodeDef), Msg]
            ),
            post_completed(NodeDef3, Msg2),
            enter_receivership(Module, NodeDef3, ReceiverType);
        CatchAll ->
            catchall_receivership(CatchAll, Module, NodeDef, ReceiverType)
    end;
enter_receivership(Module, NodeDef, Type) ->
    throw(
        io_lib:format(
            "Umatched receivership type '~p' for ~p ~p~n",
            [Type, Module, NodeDef]
        )
    ).
